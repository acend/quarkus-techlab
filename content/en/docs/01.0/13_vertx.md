---
title: "1.3 Introduction to Vert.x"
linkTitle: "1.3 Introduction to Vert.x"
weight: 130
sectionnumber: 1.3
description: >
  Introduction to Vert.x
---

Eclipse Vert.x is a toolkit provided to build reactive applications. The ecosystem is very diverse and versatile. To see the diversity head over to the official [https://vertx.io/docs/](documentation).
Quarkus is under the hood powered by Vert.x. Whenever Quarkus serves and HTTP endpoint there is a underlying Vert.x HTTP server to handle the request.


## {{% param sectionnumber %}}.1: Vert.x bare API

Vert.x provides multiple APIs. For starters we are going to take a look at the 'bare' API.
Due to the reactive nature of Vert.x, the API contains mostly asynchronous methods. They follow all a similar syntax:

```java

public void doSomething(param1, param2, Handler<AsyncResult<T>> handler) {
    // ...
}

```

Interesting here is the last parameter of the `doSomething` method. It is a function that will be used as a callback whenever the opertion succeeds or fails. Let's look at the example here:

```java

vertx.fileSystem()
    .readFile("my-file.txt", ar -> {
        if (ar.failed()) {
            System.out.println("D'oh! Cannot read the file: " + ar.cause());
        } else {
            System.out.println("File content is: " + ar.result());
        }
    });

```

The code reads a file as an asynchronous operation and invokes the callback when the file is read. The `Handler<AsyncResult<T>>` handles the file read and provides methods (`cause()`, `failed()`, `result()`) to compute the file read.

Due to the syntax of this bare API the Vert.x APIs will be generated by a code generator that translates the bare API into other fitting APIs.


## {{% param sectionnumber %}}.2: Vert.x Mutiny API

Mutiny is an event-driven reactive programming library and not related to Vert.x. With the uniformity of the Vert.x API all the code generated can be transformed to the Mutiny API. The Mutiny API is pretty simple and effective. At it's core it provides two types (`Multi` and `Uni`), which handle all kinds of asynchronous interactions.

When working with Mutiny you design a pipeline in which events flow. The code observes events and reacts to them. Events are published by `Publishers` and consumed by `Subscribers`, which again can handle as `Publishers` to distribute events further down the pipeline.


## {{% param sectionnumber %}}.2.1: Multi and Uni

Mutiny defines two reactive types:

* Multi - representing streams of 0...* items
* Uni - represents a stream receiving either an item or a failure

Their usages might look like this:

```java

Multi.createFrom().items("a", "b", "c")
  .onItem().transform(String::toUpperCase)
  .subscribe().with(
    item -> System.out.println("Received: " + item),
    failure -> System.out.println("Failed with " + failure)
);

Uni.createFrom().item("a")
  .onItem().transform(String::toUpperCase)
  .subscribe().with(
    item -> System.out.println("Received: " + item),
    failure -> System.out.println("Failed with " + failure)
);

```

The transformed code example from above to Mutiny will look like this:

```java

Uni<Buffer> uni = vertx.fileSystem().readFile("my-file.txt");
uni.subscribe()
  .with(it -> System.out.println("File content is: " + it));

```

To dive further into the Mutiny framework consider checking their [https://smallrye.io/smallrye-mutiny/guides](documentation).
